<!DOCTYPE html>
<html>
<head>
    <title>Crypto Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/emailjs-com@2/dist/email.min.js"></script>
</head>
<style>
    /* Set the font for all tables */
    table {
        font-family: Arial, sans-serif;
        width: 100%; /* Make all tables the same width */
        table-layout: fixed; /* Enable word-wrapping for cells */
        margin-top: 1em; /* Add vertical space above the table */
        margin-bottom: 1em; /* Add vertical space below the table */
    }

    /* Align all text in tables to the left */
    table th, table td {
        text-align: left;
    }

    /* Make the action names bold */
    table .action {
        font-weight: bold;
    }

    #log {
        margin-top: 300px;
    }
</style>
<body>
    <div>Last fetch: <span id="time-since" style="font-weight: bold;"></span> minutes ago.</div>
    <div id="dataContainer"></div>
    <script>

        Notification.requestPermission().then(function(permission) {});

        // Configurable values
        const apiKey = 'YOUR_BINANCE_API_KEY';
        const apiSecret = 'YOUR_BINANCE_API_SECRET';
        const symbols = ["HIGHUSDT", "BTCUSDT"];
        memmory = [];

        // Ichimoku Cloud settings
        const conversionPeriods = 9;
        const basePeriods = 26;
        const laggingSpan2Periods = 52;
        const displacement = 26;

        function donchian(len, data) {
            const slice = data.slice(-len);
            const low = Math.min(...slice.map(kline => parseFloat(kline[3])));
            const high = Math.max(...slice.map(kline => parseFloat(kline[2])));
            return (low + high) / 2;
        }

        // Data fetch function
        const fetchData = async () => {

            container = document.getElementById('dataContainer');
            container.innerHTML = "";

            for (const symbol of symbols) {

                //track coin status for conditions
                var cloudColor = "";
                var greenBlue  = "";
                var pricePosGreen = "";
                var pricePosCloud = "";
                var pricePosLagging = ""; 

                // Pause for 200 ms
                await new Promise(resolve => setTimeout(resolve, 200));

                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=120`, {
                    headers: {
                        //'X-MBX-APIKEY': apiKey
                    }
                });
                const data = await response.json();
                
                const currentPrice = parseFloat(data[data.length - 1][4]);
                const currentPrice26PeriodsAgo = parseFloat(data[data.length - 26 - 1][4]);
                const conversionLine = donchian(conversionPeriods, data);
                const baseLine = donchian(basePeriods, data);
                const leadLine1 = (conversionLine + baseLine) / 2;
                const leadLine2 = donchian(laggingSpan2Periods, data);
                const leadLine1Past = (data.length > 26) ? ((donchian(conversionPeriods, data.slice(0, -26)) + donchian(basePeriods, data.slice(0, -26))) / 2) : null;
                const leadLine2Past = (data.length > 26) ? donchian(laggingSpan2Periods, data.slice(0, -26)) : null;

                let action = "NONE";
                let attention = "";
                let actionColor = null;

                //set the coin conditions status
                // cloudColor
                if (leadLine1 > leadLine2){
                    cloudColor = "LONG";
                } else {
                    cloudColor = "SHORT";
                }

                // greenBlue
                if (conversionLine > baseLine){
                    greenBlue = "LONG";
                } else {
                    greenBlue = "SHORT";
                }

                // pricePosGreen
                if (currentPrice > conversionLine){
                    pricePosGreen = "LONG";
                } else {
                    pricePosGreen = "SHORT";
                }

                // pricePosCloud
                if (currentPrice > leadLine1Past && currentPrice > leadLine2Past){
                    pricePosCloud = "LONG";
                } else if (currentPrice < leadLine1Past && currentPrice < leadLine2Past) {
                    pricePosCloud = "SHORT";
                }

                // pricePosLagging
                if (currentPrice26PeriodsAgo > currentPrice){
                    pricePosLagging = "LONG";
                } else {
                    pricePosLagging = "SHORT";
                }

                //check if conditions align and there is a signal
                if (cloudColor == "LONG" && greenBlue == "LONG" && pricePosGreen == "LONG" && pricePosCloud == "LONG" && pricePosLagging == "LONG") {
                    action = "LONG";
                    actionColor = "#35c82e";
                    if (currentPrice - leadLine2Past > 0 && Math.abs(currentPrice - leadLine2Past) < 0.003 * currentPrice){
                        attention = "!";
                    }
                    if (currentPrice - leadLine2Past > 0 && Math.abs(currentPrice - leadLine2Past) < 0.002 * currentPrice){
                        attention += "!";
                    }
                    if (currentPrice - leadLine2Past > 0 && Math.abs(currentPrice - leadLine2Past) < 0.001 * currentPrice){
                        attention += "!";
                    }
                    if (currentPrice - leadLine2Past > 0 && Math.abs(currentPrice - leadLine2Past) < 0.0005 * currentPrice){
                        attention += " HOT";
                    }

                } else if (cloudColor == "SHORT" && greenBlue == "SHORT" && pricePosGreen == "SHORT" && pricePosCloud == "SHORT" && pricePosLagging == "SHORT") {
                    action = "SHORT";
                    actionColor = "#f71102";
                    if (leadLine1Past - currentPrice > 0 && Math.abs(leadLine1 - currentPrice) < 0.003 * currentPrice ){
                        attention = "!";
                    }
                    if (leadLine1Past - currentPrice > 0 && Math.abs(leadLine1 - currentPrice) < 0.002 * currentPrice ){
                        attention += "!";
                    }
                    if (leadLine1Past - currentPrice > 0 && Math.abs(leadLine1 - currentPrice) < 0.001 * currentPrice ){
                        attention += "!";
                    }
                    if (leadLine1Past - currentPrice > 0 && Math.abs(leadLine1 - currentPrice) < 0.0005 * currentPrice ){
                        attention += " HOT";
                    }

                } else if (Math.abs(baseLine - conversionLine) < 0.003 * currentPrice) {
                    action = "EXIT";
                    actionColor = "#c92ec6";

                    if (Math.abs(baseLine - conversionLine) < 0.002 * currentPrice){
                        attention = "!";
                    }
                    if (Math.abs(baseLine - conversionLine) < 0.001 * currentPrice){
                        attention += "!";
                    }
                    if (Math.abs(baseLine - conversionLine) < 0.0005 * currentPrice){
                        attention += "!";
                    }
                }



                trend = "...";
                // general indicator that something is happening
                if (Math.abs(leadLine1 - leadLine2) < 0.002 * currentPrice) {
                    trend = "!";
                }
                if (Math.abs(leadLine1 - leadLine2) < 0.001 * currentPrice){
                    trend += "!";
                }
                if (Math.abs(leadLine1 - leadLine2) < 0.0005 * currentPrice){
                    trend += "!";
                }

                if (memmory.length < symbols.length){
                    memmory.push([symbol, action, new Date().getTime()]);
                } else {
                    for (const piece of memmory){
                        if (piece[0] == symbol){

                            if(piece[1] != action){
                                piece[1] = action;

                                // when do we want to notify somebody that a change happened? On changes to the action attribute.
                                if (action != "NONE" && ( attention == "!!!" || attention == "HOT" )){
                                    // change happened so we now need to send a notification
                                    var notification = new Notification("New cryptocurrency action", {
                                        body: "[ " + symbol + " : " + action + " ]",
                                        tag: "crypto-action",
                                    });

                                    // after the notification is sent this is a key signal and needs to be logged in a csv friendly format copy/paste
                                    var elem = document.querySelector('#log');
                                    elem.innerHTML += symbol+ ", " +action + ", " + new Date().toLocaleString() + ", null <br>";  
                                }
                            }
                            break;
                        }
                    }
                }
                

                const dataContainer = document.getElementById('dataContainer');
                let table = document.getElementById(symbol);
                if (!table) {
                    table = document.createElement('table');
                    table.id = symbol;
                    const headerRow = document.createElement('tr');
                    [
                        'Symbol',
                        'Current Price',
                        'Cloud Color', 
                        'Green/Blue', 
                        'Price/Green', 
                        'Price/Cloud', 
                        'Purple/Price 26 ago', 
                        'Interesting', 
                        'Action',  
                        'Time',
                        ].forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow.appendChild(th);
                    });
                    table.appendChild(headerRow);
                    dataContainer.appendChild(table);
                }

                const row = document.createElement('tr');
                [
                    symbol, 
                    currentPrice, 
                    cloudColor, 
                    greenBlue, 
                    pricePosGreen, 
                    pricePosCloud, 
                    pricePosLagging,
                    trend,
                    action + attention,
                    new Date().toLocaleString()
                    ].forEach(cellData => {
                    const td = document.createElement('td');
                    
                    const strong = document.createElement('strong');
                    if (cellData == "LONG"){
                        strong.style.color = "#35c82e";
                    } else if (cellData == "SHORT") {
                        strong.style.color = "#f71102";
                    } else if (cellData == "EXIT"){
                        strong.style.color = "#c92ec6";
                    }
                    strong.textContent = cellData;
                    td.appendChild(strong);

                    row.appendChild(td);
                });
                table.appendChild(row);
            }
        };

        // Fetch data every 5 minutes
        fetchData(); // initial fetch
        setInterval(fetchData, 300000);

        // set a clock on refresh that keeps track of time since last data refresh
        setInterval(function(){
            if(typeof memmory != 'undefined' && memmory.length == symbols.length){
                var timeNow = new Date().getTime();
                var lastTime = memmory[memmory.length - 1][2];

                /* Calculate the difference in milliseconds */
                let diffMilliseconds = timeNow - lastTime;
                let diffMinutes = diffMilliseconds / 1000 / 60;
                let timer = document.getElementById('time-since');
                timer.innerHTML = diffMinutes.toFixed(1); 
                
            }

        }, 200);

    </script>
    <div id="log">
        <span>simbol, action, time, result</span><br>

    </div>
</body>
</html>
