<!DOCTYPE html>
<html>
<head>
    <title>Crypto Chart</title>
    <script src="secrets.js"></script>
    <script src="bybitApi.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/emailjs-com@2/dist/email.min.js"></script>
</head>
<style>
    /* Set the font for all tables */
    table {
        font-family: Arial, sans-serif;
        width: 100%; /* Make all tables the same width */
        table-layout: fixed; /* Enable word-wrapping for cells */
        margin-top: 1em; /* Add vertical space above the table */
        margin-bottom: 1em; /* Add vertical space below the table */
    }

    /* Align all text in tables to the left */
    table th, table td {
        text-align: left;
    }

    /* Make the action names bold */
    table .action {
        font-weight: bold;
    }

    #log {
        margin-top: 100px;
    }


</style>
<body>
    <div>Last fetch: <span id="time-since" style="font-weight: bold;"></span> minutes ago.</div>
    <div id="dataContainer"></div>
    <script>
        /*
        TO MAKE THE SCRIPT RUN YOU NEED TO RENAME THE SECRETS.EXAMPLE.JS TO SECRETS.JS AND FILL IN THE API KEYS
         */

        // On first load, ask for permission to send notifications
        Notification.requestPermission().then(function(permission) {});

        const mailjsEnabled = true; // email notifications ON/OFF
        const mailjsSymbols = ["LINAUSDT", "SOLUSDT", "BTCUSDT", "XRPUSDT", "SUIUSDT", "BELUSDT", "MAGICUSDT", "INJUSDT", "ARPAUSDT"]; // For which crypto to send EMAIL notifications
        // "HIGHUSDT", "LINAUSDT", "XRPUSDT", "SOLUSDT", "TOMOUSDT", "BELUSDT", "MAGICUSDT", "INJUSDT", "ARPAUSDT", "DOGEUSDT", "LTCUSDT"
        let symbols = ["LINAUSDT", "SOLUSDT", "BTCUSDT", "XRPUSDT", "SUIUSDT", "BELUSDT", "MAGICUSDT", "INJUSDT", "ARPAUSDT"];
        let memmory = [];
        let lastFetch = null;

        // Ichimoku Cloud settings
        const conversionPeriods = 9;
        const basePeriods = 26;
        const laggingSpan2Periods = 52;
        const displacement = 26;

        //Original function for calculating on a 1h timeframe and 52 periods - calculates what ever data on any timeframe you give it to him.
        function calculateIchimoku(data){
            // calculate the ichimoku technical indicator values 
            currentPrice = parseFloat(data[data.length - 1][4]);
            currentPrice26PeriodsAgo = parseFloat(data[data.length - 26 - 1][4]);
            conversionLine = donchian(conversionPeriods, data);
            baseLine = donchian(basePeriods, data);
            leadLine1 = (conversionLine + baseLine) / 2;
            leadLine2 = donchian(laggingSpan2Periods, data);
            leadLine1Past = (data.length > 26) ? ((donchian(conversionPeriods, data.slice(0, -26)) + donchian(basePeriods, data.slice(0, -26))) / 2) : null;
            leadLine2Past = (data.length > 26) ? donchian(laggingSpan2Periods, data.slice(0, -26)) : null;
            console.log(" currentPRice:" + currentPrice, " conversionLine:" + conversionLine, " baseLine:" + baseLine, "cloudGreen:" + leadLine1Past, " cloudRed:" + leadLine2Past, " leadLine1:" + leadLine1, " leadLine2:" + leadLine2);
        }

        // Helper function to convert 3120 daily data points to 26 hourly data points whic represent the hourly average of the hourly data points
        function calculateHourlyAverage(minuteDataArray) {
            const hourlyDataArray = [];

            // Indices of elements to average
            const indicesToAverage = [1, 2, 3, 4, 5, 7, 9];

            for(let i = 0; i < minuteDataArray.length; i += 26) {
                const hourChunk = minuteDataArray.slice(i, i + 26);

                const sums = indicesToAverage.map(index =>
                    hourChunk.reduce((acc, minuteData) => acc + parseFloat(minuteData[index]), 0)
                );

                const averages = sums.map(sum => sum / hourChunk.length);

                hourlyDataArray.push(averages);
            }
            console.log(hourlyDataArray);
            return hourlyDataArray;
        }

        // who would care to know :D
        function donchian(len, data) {
            const slice = data.slice(-len);
            const low = Math.min(...slice.map(kline => parseFloat(kline[3])));
            const high = Math.max(...slice.map(kline => parseFloat(kline[2])));
            return (low + high) / 2;
        }

        // calculate the distance between two values relative to the current price...
        function hotness(val1, val2){
            var attention = 0;
            if (Math.abs(val1 - val2) < 0.005 * val1){
                attention = 1;
            }
            if (Math.abs(val1 - val2) < 0.003 * val1){
                attention = 2;
            }
            if (Math.abs(val1 - val2) < 0.001 * val1){
                attention = 3;
            }
            if (Math.abs(val1 - val2) < 0.0005 * val1){
                attention = 4;
            }
            if (Math.abs(val1 - val2) < 0.0002 * val1){
                attention = 5;
            }
            return attention;
        }

        // send an email if something happens
        function sendEmail(symbol, action, attention, price, time){
            var templateParams = {
                subject: time,
                message: "[ " + symbol + " " + action + " " + attention + " " + price + " " + time + " ]",
            };

            if (mailjsEnabled && mailjsSymbols.includes(symbol)){
                emailjs.send(mailjsService, mailjsTemplate, templateParams, mailjsKey)
                    .then(function(response) {
                       console.log('SUCCESS!', response.status, response.text);
                    }, function(error) {
                       console.log('FAILED...', error);
                    });
            }
        }

        // Data fetch function and a bunch of shit but #shrug
        const fetchData = async (symbol = null) => {

            lastFetch = new Date();
            container = document.getElementById('dataContainer');
            container.innerHTML = "";
            fetchCounter = 0;
            inteval = "1h";
            maxRetries = 3;

            if(symbol != null){
                symbols = [symbol];
            }

            for (const symbol of symbols) {
                fetchCounter++;
                //track coin status for conditions
                let cloudColor = "";
                let greenBlue  = "";
                let pricePosGreen = "";
                let pricePosCloud = "";
                let bluePosCloud = "";
                let pricePosLagging = "";
                let data;
                let data_minutes;

                // here it is a better fetch with retries ... this makes sure we got data and we can run LONG/SHORT and EXIT's 
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=52`, {
                            headers: {
                                //'X-MBX-APIKEY': apiKey
                            }
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        } else {
                            data = await response.json();
                            break;
                        }

                    } catch (error) {
                        console.error(`Attempt ${i + 1} failed - ${error}`);
                        if (i == maxRetries - 1) {  // If last retry attempt, rethrow the error
                            throw error;
                        }
                        // Wait before making the next attempt
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }

                calculateIchimoku(data);


                let action = "NONE";
                let attention = "";
                let actionColor = null;

                //set the coin conditions status
                // this are tell what signal to identify and describe the rules 
                
                // cloudColor - the color of the ichimoku cloud 26 PERIODS ahead
                // Green -> Long
                // Red -> Short
                if (leadLine1 > leadLine2){
                    cloudColor = "LONG";
                } else {
                    cloudColor = "SHORT";
                }

                // greenBlue 
                if (conversionLine > baseLine){
                    greenBlue = "LONG";
                } else {
                    greenBlue = "SHORT";
                }

                // pricePosGreen
                if (currentPrice > conversionLine){
                    pricePosGreen = "LONG";
                } else {
                    pricePosGreen = "SHORT";
                }

                // pricePosCloud - now this one is for checking where the current price is in comparison to the ichimoku cloud NOW
                if (currentPrice > leadLine1Past && currentPrice > leadLine2Past){
                    pricePosCloud = "LONG";
                } else if (currentPrice < leadLine1Past && currentPrice < leadLine2Past) {
                    pricePosCloud = "SHORT";
                } else {
                    pricePosCloud = "IN CLOUD"
                }

                // bluePosCloud - this one does the same thing but for the base line compared to the ichimoku cloud NOW
                if (baseLine > leadLine1Past && baseLine > leadLine2Past){
                    bluePosCloud = "LONG";
                } else if(baseLine < leadLine1Past && baseLine < leadLine2Past) {
                    bluePosCloud = "SHORT";
                } else {
                    bluePosCloud = "IN CLOUD";
                }

                // this one if for comparing the lagging price with the coin price 26 periods back... the console log explains it
                // console.log('candle:'+currentPrice26PeriodsAgo, " / purple:"+currentPrice);
                if (currentPrice > currentPrice26PeriodsAgo){
                    pricePosLagging = "LONG";
                } else {
                    pricePosLagging = "SHORT";
                }

                //CHECK IF LONG ONGOING
                if (cloudColor == "LONG" && greenBlue == "LONG" && pricePosGreen == "LONG" && pricePosCloud == "LONG" && bluePosCloud == "LONG" && pricePosLagging == "LONG") {
                    action = "LONG";

                    // How hot are the current price and base line. At this point both are out of the cloud. 
                    // The attention tells how close we are to the cloud. Higher is better. Needs more attention. Values: 5-0
                    attention_1 = hotness(baseLine, leadLine2Past);
                    attention_2 = hotness(currentPrice, leadLine2Past);
                    attention = attention_1 > attention_2 ? attention_1 : attention_2;

                // CHECK IF CLOSE TO LONG - Usually the base line is the last one to exit the cloud and this tells how close we are for it to happen. Last condition before things happen. 
                } else if(cloudColor == "LONG" && greenBlue == "LONG" && pricePosGreen == "LONG" && pricePosCloud == "LONG" && bluePosCloud == "IN CLOUD" && pricePosLagging == "LONG"){
                    action = "?LONG?";

                    attention_1 = hotness(baseLine, leadLine2Past);
                    attention_2 = hotness(currentPrice, leadLine2Past);
                    attention = attention_1 > attention_2 ? attention_1 : attention_2;

                // CHECK IF SHORT ONGOING - opposite from long
                } else if (cloudColor == "SHORT" && greenBlue == "SHORT" && pricePosGreen == "SHORT" && pricePosCloud == "SHORT" && bluePosCloud == "SHORT" && pricePosLagging == "SHORT") {
                    action = "SHORT";

                    // How hot are the current price and base line. Same as for short
                    attention_1 = hotness(baseLine, leadLine2Past);
                    attention_2 = hotness(currentPrice, leadLine2Past);
                    attention = attention_1 > attention_2 ? attention_1 : attention_2;

                // CHECK IF CLOSE TO SHORT - oposite of possible long
                } else if (cloudColor == "SHORT" && greenBlue == "SHORT" && pricePosGreen == "SHORT" && pricePosCloud == "SHORT" && bluePosCloud == "IN CLOUD" && pricePosLagging == "SHORT"){
                    action = "?SHORT?";

                    attention_1 = hotness(baseLine, leadLine2Past);
                    attention_2 = hotness(currentPrice, leadLine2Past);
                    attention = attention_1 > attention_2 ? attention_1 : attention_2

                // CHECK IF THERE IS A LAST CHANCE EXIT - last stop. exit the trade.
                } else if (Math.abs(baseLine - conversionLine) < 0.003 * currentPrice) {
                    action = "EXIT";

                    // how close are the base line and conversion line from crossing
                    attention = hotness(baseLine, conversionLine);
                    
                }

                // CHCECK ICHIMOKU CLOUD CHANGES COLOR - the two lead lines can cross and this often indicates a trend change. Or reinforces other parameters. This is 26 periods ahead of current price.
                trend = hotness(leadLine1, leadLine2) + "";

                // now this sucks :D:D:D what ever ... 
                if (memmory.length < symbols.length){
                    memmory.push([symbol, action, new Date().getTime(), greenBlue]);
                } else {
                    for (const piece of memmory){
                        if (piece[0] == symbol){

                            // The important information: A strong signal to watch the graph is ?LONG? or ?SHORT? if the next signal is LONG or SHORT you need to short. Trust it. #fingerscrossed
                            if(piece[1] != action){
                                var old_action = piece[1];
                                piece[1] = action;

                                // On changes to the action of the coin we send a notification
                                if (action != "NONE"){

                                    // change happened so we now need to send a notification
                                    var notification = new Notification("New cryptocurrency action", {
                                        body: "[ " + symbol + " : " + action + " ]",
                                        tag: "crypto-action",
                                    });

                                    // after the notification is sent this is a key signal and needs to be logged in a csv friendly format copy/paste
                                    var elem = document.querySelector('#log');
                                    elem.innerHTML += symbol+ ", " +action + ", " + attention + ", " + currentPrice + ", " + new Date().toLocaleString() + ", null <br>";

                                    // IMPORTANT ENTER SIGNAL- this is where you send an email because you went from being close to crossing the cloud with the price and base line
                                    if((old_action == "?LONG?" || old_action == "?SHORT?") && (action == "LONG" || action == "SHORT")){
                                        sendEmail(symbol, "ENTER NOW", attention, currentPrice, new Date().toLocaleString());
                                        console.log(symbol, "ENTER NOW", attention, currentPrice, new Date().toLocaleString());
                                    }

                                    // IMPORTANT EXIT SIGNAL Here we check if there was an exit signal and if blue and green had switched. Then new alert
                                    if(action == "EXIT"){
                                        var old_direction = piece[3];
                                        if (old_direction != greenBlue){
                                            greenBlue = piece[3];
                                            sendEmail(symbol, "EXIT NOW", attention, currentPrice, new Date().toLocaleString());
                                            console.log(symbol, "EXIT NOW", attention, currentPrice, new Date().toLocaleString());
                                        }

                                    }
                                }
                            // IMPORTANT EXIT SIGNAL - this is when the cross happened between conversion line and base line. You are now out of the trade.
                            }
                            break;
                        }
                    }
                }
                
                // this also sucks balls but who cares ... chatgpt again :D:D:D 
                const dataContainer = document.getElementById('dataContainer');
                let table = document.getElementById(symbol);
                if (!table) {
                    table = document.createElement('table');
                    table.id = symbol;
                    const headerRow = document.createElement('tr');
                    [
                        '',
                        'Symbol',
                        'Current Price',
                        'Cloud Color',
                        'Green/Blue', 
                        'Price/Green', 
                        'Price/Cloud',
                        'Blue/Cloud',
                        'Purple/Price 26 ago',
                        'Interesting',
                        'Action',
                        'Time',
                        ].forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow.appendChild(th);
                    });
                    table.appendChild(headerRow);
                    dataContainer.appendChild(table);
                }

                const row = document.createElement('tr');
                [
                    fetchCounter,
                    symbol, 
                    currentPrice, 
                    cloudColor, 
                    greenBlue, 
                    pricePosGreen, 
                    pricePosCloud,
                    bluePosCloud,
                    pricePosLagging,
                    trend,
                    action + " " + attention,
                    new Date().toLocaleString()
                    ].forEach(cellData => {
                    const td = document.createElement('td');
                    
                    const strong = document.createElement('strong');
                    cellData += "";
                    
                    if (cellData.indexOf("LONG") != -1){
                        strong.style.color = "#35c82e";
                    } else if (cellData.indexOf("SHORT") != -1) {
                        strong.style.color = "#f71102";
                    } else if (cellData.indexOf("EXIT") != -1){
                        strong.style.color = "#c92ec6";
                    }

                    strong.textContent = cellData;
                    td.appendChild(strong);

                    row.appendChild(td);
                });
                table.appendChild(row);

                //added to make it go nice with the api... rate limit. maybe can be faster
                let delay = 0;
                // Pause for a bit between requests
                await new Promise(resolve => setTimeout(resolve, delay));

            }
        };

        // Fetch data every 3 minutes
        fetchData(); // initial fetch
        setInterval(fetchData, 180000);

        // set a clock on refresh that keeps track of time since last data refresh
        setInterval(function(){
            if(typeof memmory != 'undefined' && memmory.length == symbols.length){
                var timeNow = new Date().getTime();
                var lastTime = lastFetch.getTime();

                /* Calculate the difference in milliseconds */
                let diffMilliseconds = timeNow - lastTime;
                let diffMinutes = diffMilliseconds / 1000 / 60;
                let timer = document.getElementById('time-since');
                timer.innerHTML = diffMinutes.toFixed(1); 
                
            }

        }, 200);

    </script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js">
    </script>

    <div id="log">
        <span>simbol, action, price, time, result</span><br>

    </div>
</body>
</html>
