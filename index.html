<!DOCTYPE html>
<html>
<head>
    <title>Crypto Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/emailjs-com@2/dist/email.min.js"></script>
</head>
<style>
    /* Set the font for all tables */
    table {
        font-family: Arial, sans-serif;
        width: 100%; /* Make all tables the same width */
        table-layout: fixed; /* Enable word-wrapping for cells */
        margin-top: 1em; /* Add vertical space above the table */
        margin-bottom: 1em; /* Add vertical space below the table */
    }

    /* Align all text in tables to the left */
    table th, table td {
        text-align: left;
    }

    /* Make the action names bold */
    table .action {
        font-weight: bold;
    }

    #log {
        margin-top: 100px;
    }
</style>
<body>
    <div>Last fetch: <span id="time-since" style="font-weight: bold;"></span> minutes ago.</div>
    <div id="dataContainer"></div>
    <script>

        Notification.requestPermission().then(function(permission) {});

        // Configurable values
        const apiKey = 'YOUR_BINANCE_API_KEY'; // not needed
        const apiSecret = 'YOUR_BINANCE_API_SECRET'; // not needed 
        const symbols = ["HIGHUSDT", "BTCUSDT", "LINAUSDT", "XRPUSDT", "SOLUSDT", "TOMOUSDT", "BELUSDT", "MAGICUSDT", "INJUSDT", "ARPAUSDT"];
        memmory = [];
        lastFetch = null;

        // Ichimoku Cloud settings
        const conversionPeriods = 9;
        const basePeriods = 26;
        const laggingSpan2Periods = 52;
        const displacement = 26;

        // who would care to know :D
        function donchian(len, data) {
            const slice = data.slice(-len);
            const low = Math.min(...slice.map(kline => parseFloat(kline[3])));
            const high = Math.max(...slice.map(kline => parseFloat(kline[2])));
            return (low + high) / 2;
        }

        // calculate the distance between two values relative to the current price... 
        function hotness(val1, val2){
            var attention = 0;
            if (Math.abs(val1 - val2) < 0.005 * val1){
                attention = 1;
            }
            if (Math.abs(val1 - val2) < 0.003 * val1){
                attention = 2;
            }
            if (Math.abs(val1 - val2) < 0.001 * val1){
                attention = 3;
            }
            if (Math.abs(val1 - val2) < 0.0005 * val1){
                attention = 4;
            }
            if (Math.abs(val1 - val2) < 0.0002 * val1){
                attention = 5;
            }
            return attention;
        }

        // Data fetch function and a bunch of shit but #shrug
        const fetchData = async () => {

            lastFetch = new Date();
            container = document.getElementById('dataContainer');
            container.innerHTML = "";
            fetchCounter = 0;

            for (const symbol of symbols) {
                fetchCounter++;
                //track coin status for conditions
                var cloudColor = "";
                var greenBlue  = "";
                var pricePosGreen = "";
                var pricePosCloud = "";
                var bluePosCloud = "";
                var pricePosLagging = "";
                var delay = 500;

                //added to make it go nice with the api... rate limit. maybe can be faster
                if(fetchCounter > 5){
                    delay += 1500;
                } else if (fetchCounter > 9){
                    delay += 35000;
                } else if (fetchCounter > 12){
                    delay += 6000;
                }

                // Pause for a bit between requests
                await new Promise(resolve => setTimeout(resolve, delay));

                // we get the hourly binance data for the past 5 days in 1 hour interval, the price is fetched in 5 min intervals... can be played with TBH
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=1h&limit=120`, {
                    headers: {
                        //'X-MBX-APIKEY': apiKey
                    }
                });
                const data = await response.json();
                
                // calculate the ichimoku technical indicator values 
                const currentPrice = parseFloat(data[data.length - 1][4]);
                const currentPrice26PeriodsAgo = parseFloat(data[data.length - 26 - 1][4]);
                const conversionLine = donchian(conversionPeriods, data);
                const baseLine = donchian(basePeriods, data);
                const leadLine1 = (conversionLine + baseLine) / 2;
                const leadLine2 = donchian(laggingSpan2Periods, data);
                const leadLine1Past = (data.length > 26) ? ((donchian(conversionPeriods, data.slice(0, -26)) + donchian(basePeriods, data.slice(0, -26))) / 2) : null;
                const leadLine2Past = (data.length > 26) ? donchian(laggingSpan2Periods, data.slice(0, -26)) : null;
                console.log(" currentPRice:" + currentPrice, " conversionLine:" + conversionLine, " baseLine:" + baseLine, "cloudGreen:" + leadLine1Past, " cloudRed:" + leadLine2Past, " leadLine1:" + leadLine1, " leadLine2:" + leadLine2);

                let action = "NONE";
                let attention = "";
                let actionColor = null;

                //set the coin conditions status
                // this are tell what signal to identify and describe the rules 
                
                // cloudColor - the color of the ichimoku cloud 26 PERIODS ahead
                // Green -> Long
                // Red -> Short
                if (leadLine1 > leadLine2){
                    cloudColor = "LONG";
                } else {
                    cloudColor = "SHORT";
                }

                // greenBlue 
                if (conversionLine > baseLine){
                    greenBlue = "LONG";
                } else {
                    greenBlue = "SHORT";
                }

                // pricePosGreen
                if (currentPrice > conversionLine){
                    pricePosGreen = "LONG";
                } else {
                    pricePosGreen = "SHORT";
                }

                // pricePosCloud - now this one is for checking where the current price is in comparison to the ichimoku cloud NOW
                if (currentPrice > leadLine1Past && currentPrice > leadLine2Past){
                    pricePosCloud = "LONG";
                } else if (currentPrice < leadLine1Past && currentPrice < leadLine2Past) {
                    pricePosCloud = "SHORT";
                } else {
                    pricePosCloud = "IN CLOUD"
                }

                // bluePosCloud - this one does the same thing but for the base line compared to the ichimoku cloud NOW
                if (baseLine > leadLine1Past && baseLine > leadLine2Past){
                    bluePosCloud = "LONG";
                } else if(baseLine < leadLine1Past && baseLine < leadLine2Past) {
                    bluePosCloud = "SHORT";
                } else {
                    pricePosCloud = "IN CLOUD";
                }

                // this one if for comparing the lagging price with the coin price 26 periods back... the console log explains it
                // console.log('candle:'+currentPrice26PeriodsAgo, " / purple:"+currentPrice);
                if (currentPrice > currentPrice26PeriodsAgo){
                    pricePosLagging = "LONG";
                } else {
                    pricePosLagging = "SHORT";
                }

                //CHECK IF LONG ONGOING
                if (cloudColor == "LONG" && greenBlue == "LONG" && pricePosGreen == "LONG" && pricePosCloud == "LONG" && bluePosCloud == "LONG" && pricePosLagging == "LONG") {
                    action = "LONG";
                    actionColor = "#35c82e";

                    // How hot are the current price and base line. At this point both are out of the cloud. 
                    // The attention tells how close we are to the cloud. Higher is better. Needs more attention. Values: 5-0
                    attention_1 = hotness(currentPrice, leadLine2Past);
                    attention_2 = hotness(baseLine, leadLine2Past);
                    attention = attention_1 > attention_2 ? attention_1 : attention_2;

                // CHECK IF CLOSE TO LONG - Usually the base line is the last one to exit the cloud and this tells how close we are for it to happen. Last condition before things happen. 
                } else if(cloudColor == "LONG" && greenBlue == "LONG" && pricePosGreen == "LONG" && pricePosCloud == "LONG" && bluePosCloud == "IN CLOUD" && pricePosLagging == "LONG"){

                    attention = hotness(baseLine, leadLine2);
                    if (attention > 2){
                        action = "?LONG?";
                    }

                // CHECK IF SHORT ONGOING - oposite from long
                } else if (cloudColor == "SHORT" && greenBlue == "SHORT" && pricePosGreen == "SHORT" && pricePosCloud == "SHORT" && bluePosCloud == "SHORT" && pricePosLagging == "SHORT") {
                    action = "SHORT";
                    actionColor = "#f71102";

                    // How hot are the current price and base line. Same as for short
                    attention_1 = hotness(leadLine1Past, currentPrice);
                    attention_2 = hotness(leadLine1Past, baseLine);
                    attention = attention_1 > attention_2 ? attention_1 : attention_2;

                // CHECK IF CLOSE TO SHORT - oposite of possible long
                } else if (cloudColor == "SHORT" && greenBlue == "SHORT" && pricePosGreen == "SHORT" && pricePosCloud == "SHORT" && bluePosCloud == "IN CLOUD" && pricePosLagging == "SHORT"){

                    attention = hotness(baseLine, leadLine2);
                    if (attention > 2){
                        action = "?SHORT?";
                    }

                // CHECK IF THERE IS A LAST CHANCE EXIT - last stop. exit the trade.
                } else if (Math.abs(baseLine - conversionLine) < 0.003 * currentPrice) {
                    action = "EXIT";
                    actionColor = "#c92ec6";

                    // how close are the base line and conversion line from crossing
                    attention = hotness(baseLine, conversionLine);
                }

                // What if we do another call to binance and get the 30 min of 45 min time frame and run it through ichimoku again. to narrow it down...
                if (action == "?LONG?" || action == "?SHORT?" || action == "LONG" || action == "SHORT"){
                    // we do the call guh... refactor 
                }

                // CHCECK ICHIMOKU CLOUD CHANGES COLOR - the two lead lines can cross and this often indicates a trend change. Or reinforces other parameters. This is 26 periods ahead of current price.
                trend = hotness(leadLine1, leadLine2) + "";

                // now this sucks :D:D:D what ever ... 
                if (memmory.length < symbols.length){
                    memmory.push([symbol, action, new Date().getTime()]);
                } else {
                    for (const piece of memmory){
                        if (piece[0] == symbol){

                            if(piece[1] != action){
                                piece[1] = action;

                                // when do we want to notify somebody that a change happened? On changes to the action attribute.
                                if (action != "NONE"){
                                    // change happened so we now need to send a notification
                                    var notification = new Notification("New cryptocurrency action", {
                                        body: "[ " + symbol + " : " + action + " ]",
                                        tag: "crypto-action",
                                    });

                                    // after the notification is sent this is a key signal and needs to be logged in a csv friendly format copy/paste
                                    var elem = document.querySelector('#log');
                                    elem.innerHTML += symbol+ ", " +action + ", " + currentPrice + ", " + new Date().toLocaleString() + ", null <br>";  
                                }
                            }
                            break;
                        }
                    }
                }
                

            // this also sucks balls but who cares ... chatgpt again :D:D:D 
                const dataContainer = document.getElementById('dataContainer');
                let table = document.getElementById(symbol);
                if (!table) {
                    table = document.createElement('table');
                    table.id = symbol;
                    const headerRow = document.createElement('tr');
                    [
                        '',
                        'Symbol',
                        'Current Price',
                        'Cloud Color', 
                        'Green/Blue', 
                        'Price/Green', 
                        'Price/Cloud',
                        'Blue/Cloud',
                        'Purple/Price 26 ago', 
                        'Interesting', 
                        'Action',  
                        'Time',
                        ].forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow.appendChild(th);
                    });
                    table.appendChild(headerRow);
                    dataContainer.appendChild(table);
                }

                const row = document.createElement('tr');
                [
                    fetchCounter,
                    symbol, 
                    currentPrice, 
                    cloudColor, 
                    greenBlue, 
                    pricePosGreen, 
                    pricePosCloud,
                    bluePosCloud,
                    pricePosLagging,
                    trend,
                    action + " " + attention,
                    new Date().toLocaleString()
                    ].forEach(cellData => {
                    const td = document.createElement('td');
                    
                    const strong = document.createElement('strong');
                    cellData += "";
                    
                    if (cellData.indexOf("LONG") != -1){
                        strong.style.color = "#35c82e";
                    } else if (cellData.indexOf("SHORT") != -1) {
                        strong.style.color = "#f71102";
                    } else if (cellData.indexOf("EXIT") != -1){
                        strong.style.color = "#c92ec6";
                    }

                    strong.textContent = cellData;
                    td.appendChild(strong);

                    row.appendChild(td);
                });
                table.appendChild(row);
            }
        };

        // Fetch data every 5 minutes
        fetchData(); // initial fetch
        setInterval(fetchData, 300000);

        // set a clock on refresh that keeps track of time since last data refresh
        setInterval(function(){
            if(typeof memmory != 'undefined' && memmory.length == symbols.length){
                var timeNow = new Date().getTime();
                var lastTime = lastFetch.getTime();

                /* Calculate the difference in milliseconds */
                let diffMilliseconds = timeNow - lastTime;
                let diffMinutes = diffMilliseconds / 1000 / 60;
                let timer = document.getElementById('time-since');
                timer.innerHTML = diffMinutes.toFixed(1); 
                
            }

        }, 200);

    </script>
    <div id="log">
        <span>simbol, action, price, time, result</span><br>

    </div>
</body>
</html>
